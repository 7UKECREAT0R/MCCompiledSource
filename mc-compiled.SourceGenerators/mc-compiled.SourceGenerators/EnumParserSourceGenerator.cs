using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace mc_compiled.SourceGenerators;

[Generator]
public class EnumParserSourceGenerator : ISourceGenerator
{
    private const string TargetAttributeName = "UsableInMCCAttribute";
    private static readonly string[] LANGUAGE_KEYWORDS =
    [
        "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked",
        "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else",
        "enum", "event", "explicit", "extern", "false", "finally", "fixed", "float", "for",
        "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock",
        "long", "namespace", "new", "null", "object", "operator", "out", "override", "params",
        "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed",
        "short", "sizeof", "stackalloc", "static", "string", "struct", "switch", "this", "throw",
        "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using",
        "virtual", "void", "volatile", "while"
    ];

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new EnumSyntaxReceiver());
    }
    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxContextReceiver is not EnumSyntaxReceiver receiver)
            return;

        List<INamedTypeSymbol> enums = receiver.Candidates;
        var sourceBuilder = new StringBuilder("""
                                              // Auto generated by mc-compiled.SourceGenerators.EnumParserSourceGenerator
                                              using System;
                                              using mc_compiled.Commands;

                                              namespace mc_compiled.Commands {
                                                  public static partial class CommandEnumParser {
                                                      public static void InitializeGenerated() {
                                                          
                                              """);

        foreach (INamedTypeSymbol enumTypeSymbol in enums)
        {
            string enumFullyQualifiedName = enumTypeSymbol.ToDisplayString();
            sourceBuilder
                .Append("\t\t\t// members from ")
                .AppendLine(enumFullyQualifiedName);

            string? enumDocumentationRaw = enumTypeSymbol.GetDocumentationCommentXml();
            string? enumDocumentation = enumDocumentationRaw == null ? null : GetXMLDocSummary(enumDocumentationRaw);

            IEnumerable<IFieldSymbol> enumMembers = enumTypeSymbol
                .GetMembers()
                .OfType<IFieldSymbol>()
                .Where(m => m.Kind == SymbolKind.Field);

            foreach (IFieldSymbol enumMember in enumMembers)
            {
                string memberName = enumMember.Name;
                string? memberDocumentationRaw = enumMember.GetDocumentationCommentXml();
                string? memberDocumentation = (GetXMLDocSummary(memberDocumentationRaw) ??
                                               (enumDocumentation ?? "No documentation available."))
                    .Replace("\"", "\\\"");

                string objectCreation = memberDocumentation.Contains("\n")
                    ? $"new RecognizedEnumValue(typeof({enumFullyQualifiedName}), {enumFullyQualifiedName}.{EscapeLanguageKeyword(memberName)}, \"\"\"\n{memberDocumentation}\n\"\"\")"
                    : $"new RecognizedEnumValue(typeof({enumFullyQualifiedName}), {enumFullyQualifiedName}.{EscapeLanguageKeyword(memberName)}, \"{memberDocumentation}\")";

                // base entry
                if (memberName.StartsWith("_"))
                    memberName = memberName.Substring(1);

                sourceBuilder.Append($"\t\t\tCommandEnumParser.Put(\"{memberName}\", ").Append(objectCreation)
                    .AppendLine(");");

                // add variants for spaces and dots?
                if (memberName.Contains("_"))
                {
                    sourceBuilder.Append($"\t\t\tCommandEnumParser.Put(\"{memberName.Replace("_", ".")}\", ")
                        .Append(objectCreation).AppendLine(");");
                    sourceBuilder.Append($"\t\t\tCommandEnumParser.Put(\"{memberName.Replace("_", " ")}\", ")
                        .Append(objectCreation).AppendLine(");");
                }
            }
        }

        sourceBuilder.AppendLine("\t\t}");
        sourceBuilder.AppendLine("\t}");
        sourceBuilder.AppendLine("}");

        context.AddSource("CommandEnumParser.g.cs",
            SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
    }
    private static string EscapeLanguageKeyword(string keyword)
    {
        if (string.IsNullOrEmpty(keyword))
            return string.Empty;
        if (LANGUAGE_KEYWORDS.Contains(keyword))
            return "@" + keyword;
        return keyword;
    }

    private static string? GetXMLDocSummary(string? xmlDocumentation)
    {
        if (string.IsNullOrEmpty(xmlDocumentation))
            return null;

        try
        {
            using var reader = new StringReader(xmlDocumentation);
            var xmlReader = new XmlDocument();
            xmlReader.Load(reader);
            return xmlReader.SelectSingleNode("member/summary")?.InnerText.Trim() ?? "No documentation available.";
        }
        catch (Exception exception)
        {
            return "An error occurred while parsing the XML documentation: " + exception;
        }
    }

    private class EnumSyntaxReceiver : ISyntaxContextReceiver
    {
        public List<INamedTypeSymbol> Candidates { get; } = [];

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            // filter out enum declarations
            if (context.Node is not EnumDeclarationSyntax enumDeclarationSyntax)
                return;

            // filter out enum declarations without attributes
            if (enumDeclarationSyntax.AttributeLists.Count == 0)
                return;

            // get the symbol for the enum
            INamedTypeSymbol? enumSymbol = context.SemanticModel.GetDeclaredSymbol(enumDeclarationSyntax);
            if (enumSymbol is null)
                return;

            // check if the attribute is on the enum
            if (Enumerable.Any(enumSymbol.GetAttributes(),
                    attribute => attribute.AttributeClass?.Name == TargetAttributeName))
                this.Candidates.Add(enumSymbol);
        }
    }
}